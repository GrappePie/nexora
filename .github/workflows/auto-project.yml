name: Auto add issues to Project and sync fields

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened]

permissions:
  contents: read
  issues: write

env:
  PROJECT_OWNER: GrappePie
  PROJECT_NUMBER: "1"

jobs:
  sync-project:
    runs-on: ubuntu-latest
    steps:
      - name: Sync issue to Project and fields
        uses: actions/github-script@v7
        with:
          script: |
            // ASCII-only script, no backticks or fancy unicode
            const owner = process.env.PROJECT_OWNER;
            const projectNumber = parseInt(process.env.PROJECT_NUMBER, 10);

            // Ensure we are handling an issue
            if (!context.payload.issue || !context.payload.issue.number) {
              core.info("No issue in payload. Exiting.");
              return;
            }
            const issueNumber = context.payload.issue.number;

            // Resolve ProjectV2 id (user or org)
            function nonNull(x) { return x !== null && x !== undefined; }
            const projRes = await github.graphql(
              "query($owner:String!, $projectNumber:Int!){ user(login:$owner){ projectV2(number:$projectNumber){ id } } organization(login:$owner){ projectV2(number:$projectNumber){ id } } }",
              { owner, projectNumber }
            );
            const projectId =
              (projRes.user && projRes.user.projectV2 && projRes.user.projectV2.id) ?
                projRes.user.projectV2.id :
              (projRes.organization && projRes.organization.projectV2 && projRes.organization.projectV2.id) ?
                projRes.organization.projectV2.id : null;

            if (!projectId) {
              core.setFailed("ProjectV2 not found for owner=" + owner + " number=" + projectNumber);
              return;
            }

            // Get issue node_id
            const issueData = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueNodeId = issueData.data && issueData.data.node_id ? issueData.data.node_id : null;
            if (!issueNodeId) {
              core.setFailed("Could not resolve issue node_id");
              return;
            }

            // List items in project and see if the issue is already there
            const itemsRes = await github.graphql(
              "query($projectId:ID!){ node(id:$projectId){ ... on ProjectV2 { items(first:200){ nodes { id content { __typename ... on Issue { id number title } } } } } } }",
              { projectId }
            );
            let itemId = null;
            const nodes = (((itemsRes || {}).node || {}).items || {}).nodes || [];
            for (const n of nodes) {
              if (n && n.content && n.content.__typename === "Issue" && n.content.id === issueNodeId) {
                itemId = n.id;
                break;
              }
            }

            // Add item if missing
            if (!itemId) {
              const addRes = await github.graphql(
                "mutation($projectId:ID!, $contentId:ID!){ addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } } }",
                { projectId, contentId: issueNodeId }
              );
              itemId = addRes && addRes.addProjectV2ItemById && addRes.addProjectV2ItemById.item ? addRes.addProjectV2ItemById.item.id : null;
              core.info("Added item id: " + itemId);
            } else {
              core.info("Item already in project: " + itemId);
            }
            if (!itemId) {
              core.setFailed("Could not obtain itemId");
              return;
            }

            // Fetch fields Priority / Type / Area
            const fieldsRes = await github.graphql(
              "query($projectId:ID!){ node(id:$projectId){ ... on ProjectV2 { fields(first:50){ nodes { __typename ... on ProjectV2FieldCommon { id name } ... on ProjectV2SingleSelectField { id name options { id name } } } } } } }",
              { projectId }
            );
            const fieldNodes = (((fieldsRes || {}).node || {}).fields || {}).nodes || [];
            function findSelect(name) {
              for (const f of fieldNodes) {
                if (f && f.name && f.options && String(f.name).toLowerCase() === String(name).toLowerCase()) return f;
              }
              return null;
            }
            const priorityField = findSelect("Priority");
            const typeField = findSelect("Type");
            const areaField = findSelect("Area");

            // Read labels from the issue (fresh)
            const issueView = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const labels = (issueView.data.labels || []).map(l => {
              if (typeof l === "string") return l.toLowerCase();
              if (l && l.name) return String(l.name).toLowerCase();
              return null;
            }).filter(nonNull);

            function optionIdByName(field, nameLower) {
              if (!field || !field.options) return null;
              for (const o of field.options) {
                if (o && o.name && String(o.name).toLowerCase() === nameLower) return o.id;
              }
              return null;
            }

            // Map priority from labels "priority:*"
            let prioOptId = null;
            const prios = ["priority:high","priority:medium","priority:low"];
            for (const p of prios) {
              if (labels.indexOf(p) !== -1) {
                const val = p.split(":")[1];
                prioOptId = optionIdByName(priorityField, val);
                break;
              }
            }

            // Map type from labels "type:*"
            let typeOptId = null;
            const types = ["type:epic","type:story","type:task"];
            for (const t of types) {
              if (labels.indexOf(t) !== -1) {
                const val = t.split(":")[1];
                typeOptId = optionIdByName(typeField, val);
                break;
              }
            }

            // Map area: first label that matches an Area option
            let areaOptId = null;
            if (areaField && areaField.options) {
              for (const o of areaField.options) {
                const nm = o && o.name ? String(o.name).toLowerCase() : null;
                if (nm && labels.indexOf(nm) !== -1) { areaOptId = o.id; break; }
              }
            }

            async function setSingleSelect(field, optId) {
              if (!field || !optId) return;
              await github.graphql(
                "mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optId:String!){ updateProjectV2ItemFieldValue(input:{ projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ singleSelectOptionId:$optId }}){ clientMutationId } }",
                { projectId, itemId, fieldId: field.id, optId }
              );
            }

            await setSingleSelect(priorityField, prioOptId);
            await setSingleSelect(typeField,     typeOptId);
            await setSingleSelect(areaField,     areaOptId);

            core.info("Sync OK for issue #" + issueNumber);
